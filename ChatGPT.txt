hezy.amiel@gmail.com
Hi. I have a python code, and I want to translate it to Julia, can you help?

Sure, I can help you translate your Python code to Julia. Can you please provide the code you would like to be translated? Additionally, it would be helpful if you could also specify what the code is supposed to accomplish so that I can ensure the translation is accurate.
hezy.amiel@gmail.com
Let's start with one of the functions. It takes the position and width of a Lorentzian curve, and returns the appropriate function:

def lorentzian(x, position, width):
    return (1/np.pi) * (width/2) / ((x-position)**2 + (width/2)**2)

Here is the equivalent code in Julia:

function lorentzian(x, position, width)
    return (1/π) * (width/2) / ((x-position)^2 + (width/2)^2)
end

In Julia, the ^ operator is used for exponentiation, whereas in Python the ** operator is used. Also, np is not needed in Julia as π is built-in constant.

It should be noted that the above translation is equivalent, but if you have more complex code using numpy, it might be tricky to translate it to pure Julia. In that case you can use PyCall package to use numpy from Julia.
hezy.amiel@gmail.com
My entire code is ~250 lines. It does use NumPy.  It is to create simulations of powder XRD for 3 cubic lattices: simple cubic, body centered cubic, and face centered cubic.

Translating an entire codebase of ~250 lines can be a time-consuming task, especially if it relies heavily on NumPy. The PyCall package in Julia provides a way to use the Python NumPy library from within Julia, which could be a good option to consider if you want to avoid having to rewrite the parts of the code that use NumPy.

Here's an example of how you could use PyCall to access NumPy from Julia:

using PyCall

np = pyimport("numpy")

x = np.linspace(0, 10, 1000)
y = np.sin(x)

Another option is to use Julia packages like LinearAlgebra or SparseArrays for linear algebra operations, FFTW for FFT operations and Plots for visualization, which should allow you to write most of the code in Julia.

I recommend you to take a look at the documentation of each package to see if they can help you with your specific simulation.
And also, If you have any specific questions or issues with your code, feel free to ask and I will be happy to help.
hezy.amiel@gmail.com
Using NumPy in Julia is fine. My code is rather simple in the mathematical sense. No need in FFT at this stage

Great, in that case you can use PyCall to access NumPy functions in your code. You'll need to install the PyCall package first by running ] add PyCall in the Julia REPL. Then you can use the pyimport() function to import the NumPy library and call its functions as you would in Python.

Here is an example:

using PyCall

np = pyimport("numpy")

x = np.linspace(0, 10, 1000)
y = np.sin(x)

You can then use y just like a normal Julia array and use the full power of Julia to visualize and analyze the data.

Keep in mind that using PyCall will add overhead to your code and might make it run slower than if it were implemented entirely in Julia.

I recommend you to test the performance of your simulation, if it runs slow, you might want to consider rewriting the parts of your code that use NumPy in Julia or use other Julia packages that provide similar functionality.

Please let me know if you have any question or if there is anything else I can help you with.
hezy.amiel@gmail.com
Can I paste my code, so you'll take a look and tell me what are  possible challenges I need to be aware of?

Sure, you can paste your code here and I can take a look and see if there are any specific challenges you need to be aware of when translating it to Julia. However, please keep in mind that reviewing a codebase of ~250 lines can be a time-consuming task, so it might take me some time to get back to you with a detailed analysis.

Also, please keep in mind that I am a language model, so while I can help you with general guidance, I am not able to run or test the code.

If the code is not confidential and you would like to share it in public, you can also put it on Github, and I can take a look at it there.
hezy.amiel@gmail.com
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Created on Wed Dec  7 14:56:13 2022
@author: Yehezkel Amiel

How is it now? (2023-01-10)
    seems to work fine for cubic symmetries (sc, bcc, fcc) with one element

Things to do (short term):
    [] function "intensity" should not use built in values
    [] function "make_graph" should give nicer titles
    [] add random noise
    [] add bacground
    [] investigate U,V,W values
    [] export to csv
    [] read setup and sample data from external files

For the future (long term):
    [] find Miller indecies based on lattice vectors rather than selection rules
    [] other symmetries
    [] more than one element    
"""

''' Importing lipreries '''
import numpy as np
import matplotlib.pyplot as plt
from scipy.special import wofz
#from scipy.optimize import curve_fit
#from itertools import combinations_with_replacement
from itertools import product


''' Functions '''

def lorentz(x, wL):
    # Lorentz with max=1 and w=FWHM: 
    gamma = wL
    return 1 / (1 + np.square(x/gamma)) 


def gauss(x, wG):
    # Gauss with max=1 and w=FWH
    sigma = wG/np.sqrt(2*np.log(2))
    return np.exp(- x**2 / (2* sigma**2))


def voigt(x, wL, wG):
    gamma = wL
    sigma = wG/np.sqrt(2*np.log(2))
    z = (x + 1j*gamma)/np.sqrt(2)/sigma
    return np.sqrt(2*np.pi) * np.real(wofz(z))/np.sqrt(2*np.pi)/sigma
    # normolized Voigt (integral = 1): c * np.real(wofz((x + 1j*gamma)/(sigma * np.sqrt(2)))) / (sigma * np.sqrt(2*np.pi))
    # for Lorentz sigma=0, gamma=1, c=1
    # for Gauss sigma=1, gamma=0, c=1
  
    
def pseudo_voigt(x, w, n):
    # pseudo-voigt with max=1 and w=FWHM:
    return n * gauss(x, w) + (1-n) * lorentz(x,w)


def peak(x, x0, A, w, n):
    return A * pseudo_voigt(x-x0, w, n)


def peaks_width(theta, U, V, W):
    theta_rad = theta*np.pi/180
    return np.sqrt( U*np.tan(theta_rad/2)**2 + V*np.tan(theta_rad/2) + W)


def intensity(theta_space, peaks_positions, peaks_width):
    y = np.zeros(2000)
    for n in range(np.size(peaks_positions)):
        #print(n, peaks_positions[n], peaks_width[n])
        y = y + peak(theta_space, peaks_positions[n], 1, peaks_width[n], 0.5)
    return y


def find_d(indices_list, a):
    miller = np.array(indices_list)
    return a/np.sqrt(miller.T[0]**2 + miller.T[1]**2 + miller.T[2]**2)


def bragg_angels(wavelength, d_spacings):
    sintheta = wavelength/(2*d_spacings)
    sintheta = sintheta[abs(sintheta)<=1]  # removing values outside (-1,1)
    return 2 * 180/np.pi * np.arcsin(sintheta)  # *2 for 2θ  
    

def make_graph (x, y):
    fig1, ax = plt.subplots(figsize=(14, 8))
    ax.grid(visible=True, which='both', axis='both')
    ax.minorticks_on()
    ax.set_title("XRD", fontsize=16)
    ax.set_xlabel(r"$2 \theta$", fontsize=14)
    #ax.set_xlim()
    ax.set_ylabel(r"Intensity", fontsize=14)
    #ax.set_ylim()
    ax.plot(x,y, '.r', label='experiment')
    ax.plot(x,y, '-b', label='theory')
    ax.legend()
    
'''
===== 
Setup 
=====
'''

N = 2000
theta_space = np.linspace (0, 180, N)

wavelength = 0.15418  # CuKα radiation in nm
#wavelength = 0.18125  # 
U, V, W = 0.2, 0.2, 0.2


'''
============
Simple Cubic
============
'''

''' In simple cubic lattince, all Miller indices are allowed '''
sample_list = [-5,-4,-3,-2,-1,0,1,2,3,4,5]
indices_SC = list(product(sample_list, repeat = 3))
indices_SC.remove((0,0,0))


'''
Lattice parameter for SC Polonium (α-Po)
from https://en.wikipedia.org/wiki/Polonium 
'''
a_SC = 0.3352 

d_SC = find_d(indices_SC, a_SC)

bragg_angels_SC = bragg_angels(wavelength, d_SC)
angular_intensity_SC = intensity(theta_space,
                                 bragg_angels_SC,
                                 peaks_width(bragg_angels_SC, U, V, W))
make_graph(theta_space, angular_intensity_SC)


'''
===================
Body Centered Cubic
===================
'''

''' In body centerd cubic lattice, only indices with h+k+l=even are allowed '''
indices_BCC = []
for item in indices_SC:
        if (item[0] + item[1] + item[2]) % 2 == 0:
            indices_BCC.append(item)
# print(indices_BCC)  
 
'''
Lattice parameter for BCC Tantalum (α-Ta)
from https://en.wikipedia.org/wiki/Tantalum
'''
a_BCC = 0.33058

'''
Lattice parameter for BCC Tungsten (W)
from https://en.wikipedia.org/wiki/Lattice_constant
'''
#a_BCC = 0.3155

d_BCC = find_d(indices_BCC, a_BCC)
# print(d_BCC)

bragg_angels_BCC = bragg_angels(wavelength, d_BCC)
angular_intensity_BCC = intensity(theta_space,
                                  bragg_angels_BCC,
                                  peaks_width(bragg_angels_BCC, U, V, W))
make_graph(theta_space,angular_intensity_BCC)


'''
===================
Face Centered Cubic
===================
'''

''' In face centered cubic lattice, h,k,l must all be either odd or even '''
indices_FCC = []
#print('before:' ,indices_SC)
for item in indices_SC:
        if [(-1)**item[0], (-1)**item[1] ,(-1)**item[2]] == [1,1,1]:
            indices_FCC.append(item)
        if [(-1)**item[0], (-1)**item[1] ,(-1)**item[2]] == [-1,-1,-1]:
            indices_FCC.append(item)  

'''
Lattice parameter for FCC Platinum
from https://periodictable.com/Elements/078/data.html
'''
a_FCC = 0.39242 

'''
Lattice parameter a for FCC Pb
from https://en.wikipedia.org/wiki/Lattice_constant
'''
#a_FCC = 0.4920 

d_FCC = find_d(indices_FCC, a_FCC)
# print(d_FCC)

bragg_angels_FCC = bragg_angels(wavelength, d_FCC)
angular_intensity_FCC = intensity(theta_space,
                                  bragg_angels_FCC,
                                  peaks_width(bragg_angels_FCC, U, V, W))
make_graph(theta_space,angular_intensity_FCC)

This code looks like it's written in python 3, and it appears to simulate powder XRD patterns for three different cubic lattices (simple cubic, body-centered cubic, and face-centered cubic) using NumPy and Matplotlib.

Here are some things you should be aware of when translating this code to Julia:

    Numpy: You can use PyCall to access NumPy functions in your code, as I have mentioned before. However, since most of the functionality of numpy is already available in Julia, you might want to consider replacing numpy with Julia's built-in array operations and linear algebra functionality.

    Matplotlib: Julia has several plotting libraries available, such as Plots.jl and GR.jl that provide similar functionality to Matplotlib. You'll need to modify the code that uses Matplotlib to use one of these libraries instead.

    scipy.special.wofz: This is a function that computes the Faddeeva function, which is also known as the complex error function. In Julia you can use the SpecialFunctions package to compute this function.

    itertools.product: This is a python built-in function, in Julia you can use Itertools.product to get similar functionality.

    range: In python, the range() function returns an iterator that generates a sequence of numbers. In Julia, the range() function is replaced by the collect() function.

    print: In python, the print() function is used to display output to the console. In Julia, the println() function is used for the same purpose.

    ** operator: In python the ** operator is used for exponentiation, in Julia the ^ operator is used for exponentiation

    / operator: In python 2, the / operator performs floor division when used with integers. In python 3 and in Julia, the / operator performs floating-point division.

    np.size(): In python, the np.size() function returns the number of elements in an array. In Julia the length() function is used for the same purpose.

    miller.T: In python, .T is used to transpose a matrix. In Julia, the transpose() function is used for the same purpose.

Please let me know if you have any question or if there is anything else I can help you with.
hezy.amiel@gmail.com
Thanks

You're welcome! I'm glad I could help. If you have any more question or need more help, feel free to ask.
Good luck with the code translation!
ChatGPT Jan 9 Version. Free Research Preview. Our goal is to make AI systems more natural and safe to interact with. Your feedback will help us improve.
New chat
Translate Python to Julia
Clear conversations
Dark mode
OpenAI Discord
Updates & FAQ
Log out


